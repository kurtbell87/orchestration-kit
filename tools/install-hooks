#!/usr/bin/env bash
set -euo pipefail

# ---------------------------------------------------------------------------
# install-hooks — Install git hooks for auto-bootstrapping worktrees.
#
# Installs a post-checkout hook that:
#   1. Detects worktree creation (branch checkout in new worktree)
#   2. Auto-sources .orchestration-kit.env with correct PROJECT_ROOT
#   3. Reminds about `artifact-store hydrate` when symlinks are broken
# ---------------------------------------------------------------------------

PROJECT_ROOT="${PROJECT_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"

# Resolve the shared hooks dir. Git hooks live in the main .git/hooks/
# even when running from a worktree (worktrees share hooks by default).
GIT_COMMON_DIR="$(cd "$PROJECT_ROOT" && git rev-parse --git-common-dir 2>/dev/null || echo "${PROJECT_ROOT}/.git")"
HOOKS_DIR="${GIT_COMMON_DIR}/hooks"

mkdir -p "$HOOKS_DIR"

cat > "${HOOKS_DIR}/post-checkout" << 'HOOKEOF'
#!/usr/bin/env bash
# Auto-bootstrap orchestration-kit in new worktrees.
# Installed by: orchestration-kit/tools/install-hooks

PREV_HEAD="$1"
NEW_HEAD="$2"
IS_BRANCH_CHECKOUT="$3"

# Only run on branch checkout (not file checkout)
[ "$IS_BRANCH_CHECKOUT" = "1" ] || exit 0

PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# ---------------------------------------------------------------------------
# 1. Fix .orchestration-kit.env PROJECT_ROOT if it points elsewhere
# ---------------------------------------------------------------------------
ENV_FILE="${PROJECT_ROOT}/.orchestration-kit.env"
if [ -f "$ENV_FILE" ]; then
    CURRENT_ROOT=$(grep '^export PROJECT_ROOT=' "$ENV_FILE" | head -1 | cut -d'"' -f2)
    if [ -n "$CURRENT_ROOT" ] && [ "$CURRENT_ROOT" != "$PROJECT_ROOT" ]; then
        sed -i.bak \
            -e "s|export PROJECT_ROOT=.*|export PROJECT_ROOT=\"${PROJECT_ROOT}\"|" \
            -e "s|export ORCHESTRATION_KIT_ROOT=.*|export ORCHESTRATION_KIT_ROOT=\"${PROJECT_ROOT}/orchestration-kit\"|" \
            "$ENV_FILE"
        rm -f "${ENV_FILE}.bak"
        echo "[orchestration-kit] Updated PROJECT_ROOT in .orchestration-kit.env"
    fi
fi

# ---------------------------------------------------------------------------
# 2. Check kit symlinks
# ---------------------------------------------------------------------------
NEED_INSTALL=false
for script in tdd.sh experiment.sh math.sh; do
    if [ ! -L "${PROJECT_ROOT}/.kit/${script}" ]; then
        NEED_INSTALL=true
        break
    fi
done

if $NEED_INSTALL && [ -x "${PROJECT_ROOT}/orchestration-kit/install.sh" ]; then
    echo "[orchestration-kit] Restoring kit symlinks..."
    (cd "$PROJECT_ROOT" && echo "n" | ./orchestration-kit/install.sh --skip-smoke) > /dev/null 2>&1
    # Re-fix PROJECT_ROOT after install (install.sh may overwrite)
    if [ -f "$ENV_FILE" ]; then
        sed -i.bak \
            -e "s|export PROJECT_ROOT=.*|export PROJECT_ROOT=\"${PROJECT_ROOT}\"|" \
            -e "s|export ORCHESTRATION_KIT_ROOT=.*|export ORCHESTRATION_KIT_ROOT=\"${PROJECT_ROOT}/orchestration-kit\"|" \
            "$ENV_FILE"
        rm -f "${ENV_FILE}.bak"
    fi
fi

# ---------------------------------------------------------------------------
# 3. Check artifact store hydration
# ---------------------------------------------------------------------------
BROKEN_SYMLINKS=0
while IFS= read -r link; do
    if [ ! -e "$link" ]; then
        BROKEN_SYMLINKS=$((BROKEN_SYMLINKS + 1))
    fi
done < <(find "${PROJECT_ROOT}/.kit/results" -type l 2>/dev/null)

if [ "$BROKEN_SYMLINKS" -gt 0 ]; then
    echo ""
    echo "[orchestration-kit] ${BROKEN_SYMLINKS} artifact symlinks are broken."
    echo "  Run: orchestration-kit/tools/artifact-store hydrate"
    echo ""
fi
HOOKEOF

chmod +x "${HOOKS_DIR}/post-checkout"
echo "[install-hooks] Installed post-checkout hook at ${HOOKS_DIR}/post-checkout"

# ---------------------------------------------------------------------------
# pre-push hook — auto-sync orchestration-kit subtree to upstream
# ---------------------------------------------------------------------------

cat > "${HOOKS_DIR}/pre-push" << 'HOOKEOF'
#!/usr/bin/env bash
# Auto-sync orchestration-kit/ subtree changes to upstream on push.
# Installed by: orchestration-kit/tools/install-hooks
#
# When pushing commits that touch orchestration-kit/, this hook
# automatically runs `sync-upstream push` so the standalone repo
# stays in sync without manual intervention.
#
# Set ORCHESTRATION_KIT_SKIP_SYNC=1 to disable.

[ "${ORCHESTRATION_KIT_SKIP_SYNC:-0}" = "1" ] && exit 0

PROJECT_ROOT="$(git rev-parse --show-toplevel)"
SYNC_TOOL="${PROJECT_ROOT}/orchestration-kit/tools/sync-upstream"

# Exit early if sync tool doesn't exist
[ -x "$SYNC_TOOL" ] || exit 0

# Read push info from stdin (local_ref local_sha remote_ref remote_sha)
HAS_KIT_CHANGES=false
while read -r local_ref local_sha remote_ref remote_sha; do
    # Skip deletes
    [ "$local_sha" = "0000000000000000000000000000000000000000" ] && continue

    # Determine range — if remote_sha is zero, this is a new branch
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        # New branch: check all commits reachable from local that aren't on any remote branch
        range="$local_sha"
        # Use --not --remotes to get only new commits
        if git diff-tree --no-commit-id --name-only -r "$local_sha" -- orchestration-kit/ 2>/dev/null | grep -q '^orchestration-kit/'; then
            HAS_KIT_CHANGES=true
        fi
    else
        range="${remote_sha}..${local_sha}"
        if git diff --name-only "$range" -- orchestration-kit/ 2>/dev/null | grep -q '^orchestration-kit/'; then
            HAS_KIT_CHANGES=true
        fi
    fi
done

if [ "$HAS_KIT_CHANGES" = "true" ]; then
    echo ""
    echo "[orchestration-kit] Detected orchestration-kit/ changes — syncing to upstream..."

    # Check that the upstream remote exists
    if [ -f "${PROJECT_ROOT}/.orchestration-kit.env" ]; then
        source "${PROJECT_ROOT}/.orchestration-kit.env"
    fi
    REMOTE="${ORCHESTRATION_KIT_UPSTREAM_REMOTE:-orchestration-kit-upstream}"
    if ! git remote get-url "$REMOTE" &>/dev/null; then
        echo "[orchestration-kit] WARNING: Remote '${REMOTE}' not found. Skipping upstream sync."
        echo "  Add it with: git remote add ${REMOTE} <orchestration-kit-repo-url>"
        exit 0
    fi

    # Run sync — don't block the push if it fails
    if (cd "$PROJECT_ROOT" && "$SYNC_TOOL" push) 2>&1; then
        echo "[orchestration-kit] Upstream sync complete."
    else
        echo "[orchestration-kit] WARNING: Upstream sync failed (exit $?). Push continuing."
        echo "  Run manually: orchestration-kit/tools/sync-upstream push"
    fi
    echo ""
fi

# Always allow the push to proceed
exit 0
HOOKEOF

chmod +x "${HOOKS_DIR}/pre-push"
echo "[install-hooks] Installed pre-push hook at ${HOOKS_DIR}/pre-push"
