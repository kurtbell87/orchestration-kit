#!/usr/bin/env python3
"""Global run dashboard for master-kit clones.

Usage:
  tools/dashboard register [--master-kit-root PATH] [--project-root PATH] [--label LABEL]
  tools/dashboard unregister --project-id ID
  tools/dashboard projects
  tools/dashboard index [--project-id ID]
  tools/dashboard serve [--host HOST] [--port PORT]
"""

from __future__ import annotations

import argparse
import datetime as dt
import hashlib
import json
import os
import sqlite3
import threading
import urllib.parse
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from pathlib import Path
from typing import Any

REPO_ROOT = Path(__file__).resolve().parent.parent


def now_iso() -> str:
    return dt.datetime.now(dt.timezone.utc).isoformat(timespec="seconds").replace("+00:00", "Z")


def dashboard_home() -> Path:
    raw = os.getenv("MASTER_KIT_DASHBOARD_HOME")
    if raw:
        return Path(raw).expanduser().resolve()
    return (Path.home() / ".master-kit-dashboard").resolve()


def ensure_dashboard_home() -> Path:
    home = dashboard_home()
    try:
        home.mkdir(parents=True, exist_ok=True)
        return home
    except PermissionError:
        fallback = Path("/tmp/master-kit-dashboard").resolve()
        fallback.mkdir(parents=True, exist_ok=True)
        return fallback


def registry_path() -> Path:
    return ensure_dashboard_home() / "projects.json"


def db_path() -> Path:
    return ensure_dashboard_home() / "state.db"


def rel_to(base: Path, path: Path) -> str:
    try:
        return str(path.resolve().relative_to(base.resolve()))
    except ValueError:
        return str(path)


def coerce_path(raw: str | None, fallback: Path) -> Path:
    if raw is None:
        return fallback.resolve()
    return Path(raw).expanduser().resolve()


def current_master_kit_root() -> Path:
    env_root = os.getenv("MASTER_KIT_ROOT")
    if env_root:
        return Path(env_root).expanduser().resolve()
    return REPO_ROOT


def current_project_root(default_master_kit_root: Path) -> Path:
    env_root = os.getenv("PROJECT_ROOT")
    if env_root:
        return Path(env_root).expanduser().resolve()
    return default_master_kit_root


def project_id_for(master_kit_root: Path) -> str:
    digest = hashlib.sha1(str(master_kit_root).encode("utf-8")).hexdigest()
    return digest[:12]


def load_registry() -> list[dict[str, Any]]:
    path = registry_path()
    if not path.is_file():
        return []
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return []

    if not isinstance(data, list):
        return []

    projects: list[dict[str, Any]] = []
    for item in data:
        if not isinstance(item, dict):
            continue
        project_id = item.get("project_id")
        master_kit_root = item.get("master_kit_root")
        project_root = item.get("project_root")
        label = item.get("label")
        if not all(isinstance(x, str) and x for x in (project_id, master_kit_root, project_root, label)):
            continue
        projects.append(
            {
                "project_id": project_id,
                "label": label,
                "master_kit_root": master_kit_root,
                "project_root": project_root,
                "registered_at": item.get("registered_at") if isinstance(item.get("registered_at"), str) else None,
                "updated_at": item.get("updated_at") if isinstance(item.get("updated_at"), str) else None,
            }
        )
    return projects


def save_registry(projects: list[dict[str, Any]]) -> None:
    path = registry_path()
    path.write_text(json.dumps(projects, indent=2, sort_keys=True) + "\n", encoding="utf-8")


def upsert_registry_project(*, master_kit_root: Path, project_root: Path, label: str | None) -> dict[str, Any]:
    projects = load_registry()
    master_kit_root = master_kit_root.resolve()
    project_root = project_root.resolve()

    project_id = project_id_for(master_kit_root)
    now = now_iso()
    resolved_label = label.strip() if isinstance(label, str) and label.strip() else project_root.name

    updated: list[dict[str, Any]] = []
    record: dict[str, Any] | None = None
    for item in projects:
        if item.get("project_id") == project_id:
            existing_registered = item.get("registered_at") if isinstance(item.get("registered_at"), str) else now
            record = {
                "project_id": project_id,
                "label": resolved_label,
                "master_kit_root": str(master_kit_root),
                "project_root": str(project_root),
                "registered_at": existing_registered,
                "updated_at": now,
            }
            updated.append(record)
        else:
            updated.append(item)

    if record is None:
        record = {
            "project_id": project_id,
            "label": resolved_label,
            "master_kit_root": str(master_kit_root),
            "project_root": str(project_root),
            "registered_at": now,
            "updated_at": now,
        }
        updated.append(record)

    updated.sort(key=lambda x: str(x.get("label", "")).lower())
    save_registry(updated)
    return record


def remove_registry_project(project_id: str) -> bool:
    projects = load_registry()
    filtered = [item for item in projects if item.get("project_id") != project_id]
    if len(filtered) == len(projects):
        return False
    save_registry(filtered)
    return True


def ensure_schema(conn: sqlite3.Connection) -> None:
    conn.executescript(
        """
        PRAGMA journal_mode=WAL;
        CREATE TABLE IF NOT EXISTS projects (
          project_id TEXT PRIMARY KEY,
          label TEXT NOT NULL,
          master_kit_root TEXT NOT NULL,
          project_root TEXT NOT NULL,
          registered_at TEXT,
          updated_at TEXT
        );

        CREATE TABLE IF NOT EXISTS runs (
          project_id TEXT NOT NULL,
          run_id TEXT NOT NULL,
          parent_run_id TEXT,
          kit TEXT,
          phase TEXT,
          started_at TEXT,
          finished_at TEXT,
          exit_code INTEGER,
          status TEXT,
          capsule_path TEXT,
          manifest_path TEXT,
          log_path TEXT,
          events_path TEXT,
          cwd TEXT,
          project_root TEXT,
          master_kit_root TEXT,
          agent_runtime TEXT,
          host TEXT,
          pid INTEGER,
          PRIMARY KEY(project_id, run_id)
        );

        CREATE INDEX IF NOT EXISTS idx_runs_project_started
          ON runs(project_id, started_at DESC);
        CREATE INDEX IF NOT EXISTS idx_runs_project_status
          ON runs(project_id, status);
        CREATE INDEX IF NOT EXISTS idx_runs_project_parent
          ON runs(project_id, parent_run_id);

        CREATE TABLE IF NOT EXISTS requests (
          project_id TEXT NOT NULL,
          request_id TEXT NOT NULL,
          parent_run_id TEXT,
          child_run_id TEXT,
          from_kit TEXT,
          from_phase TEXT,
          to_kit TEXT,
          to_phase TEXT,
          action TEXT,
          status TEXT,
          request_path TEXT,
          response_path TEXT,
          enqueued_ts TEXT,
          completed_ts TEXT,
          PRIMARY KEY(project_id, request_id)
        );

        CREATE INDEX IF NOT EXISTS idx_requests_project_parent
          ON requests(project_id, parent_run_id);
        CREATE INDEX IF NOT EXISTS idx_requests_project_child
          ON requests(project_id, child_run_id);
        """
    )


def parse_jsonl(path: Path) -> list[dict[str, Any]]:
    rows: list[dict[str, Any]] = []
    with path.open("r", encoding="utf-8", errors="replace") as fh:
        for line in fh:
            line = line.strip()
            if not line:
                continue
            try:
                payload = json.loads(line)
            except json.JSONDecodeError:
                continue
            if isinstance(payload, dict):
                rows.append(payload)
    return rows


def resolve_pointer(base: Path, raw: str | None) -> Path | None:
    if not raw or not isinstance(raw, str):
        return None
    p = Path(raw)
    if not p.is_absolute():
        p = base / p
    return p.resolve()


def parse_manifest_metadata(master_kit_root: Path, manifest_path: str | None) -> dict[str, Any]:
    resolved = resolve_pointer(master_kit_root, manifest_path)
    if resolved is None or not resolved.is_file():
        return {}
    try:
        payload = json.loads(resolved.read_text(encoding="utf-8"))
    except Exception:
        return {}
    if not isinstance(payload, dict):
        return {}
    metadata = payload.get("metadata")
    if not isinstance(metadata, dict):
        return {}
    return metadata


def parse_run(
    *,
    project: dict[str, Any],
    run_root: Path,
) -> tuple[dict[str, Any], list[dict[str, Any]]]:
    events_path = run_root / "events.jsonl"
    records = parse_jsonl(events_path)

    run_id = run_root.name
    run: dict[str, Any] = {
        "project_id": project["project_id"],
        "run_id": run_id,
        "parent_run_id": None,
        "kit": None,
        "phase": None,
        "started_at": None,
        "finished_at": None,
        "exit_code": None,
        "status": None,
        "capsule_path": None,
        "manifest_path": None,
        "log_path": None,
        "events_path": rel_to(project["master_kit_root_path"], events_path),
        "cwd": None,
        "project_root": project["project_root"],
        "master_kit_root": project["master_kit_root"],
        "agent_runtime": None,
        "host": None,
        "pid": None,
    }

    requests: dict[str, dict[str, Any]] = {}

    for event in records:
        event_name = event.get("event")
        ts = event.get("ts") if isinstance(event.get("ts"), str) else None

        if event_name == "run_started":
            run["run_id"] = str(event.get("run_id", run_id))
            run["parent_run_id"] = event.get("parent_run_id") if isinstance(event.get("parent_run_id"), str) else None
            run["kit"] = event.get("kit") if isinstance(event.get("kit"), str) else run["kit"]
            run["phase"] = event.get("phase") if isinstance(event.get("phase"), str) else run["phase"]
            run["started_at"] = ts or run["started_at"]
            if isinstance(event.get("project_root"), str):
                run["project_root"] = event["project_root"]
            if isinstance(event.get("master_kit_root"), str):
                run["master_kit_root"] = event["master_kit_root"]
            if isinstance(event.get("agent_runtime"), str):
                run["agent_runtime"] = event["agent_runtime"]
            if isinstance(event.get("host"), str):
                run["host"] = event["host"]
            if isinstance(event.get("pid"), int):
                run["pid"] = event["pid"]

        elif event_name == "phase_started":
            if isinstance(event.get("kit"), str):
                run["kit"] = event["kit"]
            if isinstance(event.get("phase"), str):
                run["phase"] = event["phase"]
            if isinstance(event.get("cwd"), str):
                run["cwd"] = event["cwd"]

        elif event_name == "phase_finished":
            if isinstance(event.get("exit_code"), int):
                run["exit_code"] = event["exit_code"]
            if isinstance(event.get("log_path"), str):
                run["log_path"] = event["log_path"]

        elif event_name == "capsule_written":
            if isinstance(event.get("capsule_path"), str):
                run["capsule_path"] = event["capsule_path"]

        elif event_name == "manifest_written":
            if isinstance(event.get("manifest_path"), str):
                run["manifest_path"] = event["manifest_path"]

        elif event_name == "run_finished":
            run["finished_at"] = ts or run["finished_at"]
            if isinstance(event.get("exit_code"), int):
                run["exit_code"] = event["exit_code"]
            if isinstance(event.get("capsule_path"), str):
                run["capsule_path"] = event["capsule_path"]
            if isinstance(event.get("manifest_path"), str):
                run["manifest_path"] = event["manifest_path"]
            if isinstance(event.get("agent_runtime"), str):
                run["agent_runtime"] = event["agent_runtime"]
            if isinstance(event.get("host"), str):
                run["host"] = event["host"]
            if isinstance(event.get("pid"), int):
                run["pid"] = event["pid"]

        elif event_name in {"request_enqueued", "request_completed"}:
            request_id = event.get("request_id")
            if not isinstance(request_id, str):
                continue
            rec = requests.setdefault(
                request_id,
                {
                    "project_id": project["project_id"],
                    "request_id": request_id,
                    "parent_run_id": run_id,
                    "child_run_id": None,
                    "from_kit": None,
                    "from_phase": None,
                    "to_kit": None,
                    "to_phase": None,
                    "action": None,
                    "status": None,
                    "request_path": None,
                    "response_path": None,
                    "enqueued_ts": None,
                    "completed_ts": None,
                },
            )
            if isinstance(event.get("request_path"), str):
                rec["request_path"] = event["request_path"]
            if isinstance(event.get("response_path"), str):
                rec["response_path"] = event["response_path"]
            if isinstance(event.get("child_run_id"), str):
                rec["child_run_id"] = event["child_run_id"]
            if isinstance(event.get("from_kit"), str):
                rec["from_kit"] = event["from_kit"]
            if isinstance(event.get("from_phase"), str):
                rec["from_phase"] = event["from_phase"]
            if isinstance(event.get("to_kit"), str):
                rec["to_kit"] = event["to_kit"]
            if isinstance(event.get("to_phase"), str):
                rec["to_phase"] = event["to_phase"]
            if isinstance(event.get("action"), str):
                rec["action"] = event["action"]
            if isinstance(event.get("status"), str):
                rec["status"] = event["status"]

            if event_name == "request_enqueued":
                rec["enqueued_ts"] = ts or rec["enqueued_ts"]
            else:
                rec["completed_ts"] = ts or rec["completed_ts"]

    if run["manifest_path"] is None:
        manifests = sorted((run_root / "manifests").glob("*.json"))
        if manifests:
            run["manifest_path"] = rel_to(project["master_kit_root_path"], manifests[0])

    if run["capsule_path"] is None:
        capsules = sorted((run_root / "capsules").glob("*.md"))
        if capsules:
            run["capsule_path"] = rel_to(project["master_kit_root_path"], capsules[0])

    if run["log_path"] is None:
        logs = sorted((run_root / "logs").glob("*.log"))
        if logs:
            run["log_path"] = rel_to(project["master_kit_root_path"], logs[0])

    metadata = parse_manifest_metadata(project["master_kit_root_path"], run["manifest_path"])
    if metadata:
        if run["parent_run_id"] is None and isinstance(metadata.get("parent_run_id"), str):
            run["parent_run_id"] = metadata["parent_run_id"]
        if run["kit"] is None and isinstance(metadata.get("kit"), str):
            run["kit"] = metadata["kit"]
        if run["phase"] is None and isinstance(metadata.get("phase"), str):
            run["phase"] = metadata["phase"]
        if run["started_at"] is None and isinstance(metadata.get("started_at"), str):
            run["started_at"] = metadata["started_at"]
        if run["finished_at"] is None and isinstance(metadata.get("finished_at"), str):
            run["finished_at"] = metadata["finished_at"]
        if run["exit_code"] is None and isinstance(metadata.get("exit_code"), int):
            run["exit_code"] = metadata["exit_code"]
        if run["cwd"] is None and isinstance(metadata.get("cwd"), str):
            run["cwd"] = metadata["cwd"]
        if isinstance(metadata.get("project_root"), str):
            run["project_root"] = metadata["project_root"]
        if isinstance(metadata.get("master_kit_root"), str):
            run["master_kit_root"] = metadata["master_kit_root"]
        if isinstance(metadata.get("agent_runtime"), str):
            run["agent_runtime"] = metadata["agent_runtime"]
        if isinstance(metadata.get("host"), str):
            run["host"] = metadata["host"]
        if isinstance(metadata.get("pid"), int):
            run["pid"] = metadata["pid"]

    if run["finished_at"] is None:
        run["status"] = "running"
    elif run["exit_code"] == 0:
        run["status"] = "ok"
    else:
        run["status"] = "failed"

    return run, sorted(requests.values(), key=lambda x: (x.get("enqueued_ts") or "", x["request_id"]))


def _insert_project(conn: sqlite3.Connection, project: dict[str, Any]) -> None:
    conn.execute(
        """
        INSERT INTO projects(project_id, label, master_kit_root, project_root, registered_at, updated_at)
        VALUES(?, ?, ?, ?, ?, ?)
        ON CONFLICT(project_id) DO UPDATE SET
          label = excluded.label,
          master_kit_root = excluded.master_kit_root,
          project_root = excluded.project_root,
          registered_at = excluded.registered_at,
          updated_at = excluded.updated_at
        """,
        (
            project["project_id"],
            project["label"],
            project["master_kit_root"],
            project["project_root"],
            project.get("registered_at"),
            project.get("updated_at"),
        ),
    )


def _delete_project_rows(conn: sqlite3.Connection, project_id: str) -> None:
    conn.execute("DELETE FROM runs WHERE project_id = ?", (project_id,))
    conn.execute("DELETE FROM requests WHERE project_id = ?", (project_id,))


def _insert_run(conn: sqlite3.Connection, run: dict[str, Any]) -> None:
    conn.execute(
        """
        INSERT INTO runs(
          project_id, run_id, parent_run_id, kit, phase, started_at, finished_at,
          exit_code, status, capsule_path, manifest_path, log_path, events_path,
          cwd, project_root, master_kit_root, agent_runtime, host, pid
        )
        VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """,
        (
            run["project_id"],
            run["run_id"],
            run["parent_run_id"],
            run["kit"],
            run["phase"],
            run["started_at"],
            run["finished_at"],
            run["exit_code"],
            run["status"],
            run["capsule_path"],
            run["manifest_path"],
            run["log_path"],
            run["events_path"],
            run["cwd"],
            run["project_root"],
            run["master_kit_root"],
            run["agent_runtime"],
            run["host"],
            run["pid"],
        ),
    )


def _insert_request(conn: sqlite3.Connection, request: dict[str, Any]) -> None:
    conn.execute(
        """
        INSERT INTO requests(
          project_id, request_id, parent_run_id, child_run_id,
          from_kit, from_phase, to_kit, to_phase, action,
          status, request_path, response_path, enqueued_ts, completed_ts
        )
        VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(project_id, request_id) DO UPDATE SET
          parent_run_id = excluded.parent_run_id,
          child_run_id = excluded.child_run_id,
          from_kit = excluded.from_kit,
          from_phase = excluded.from_phase,
          to_kit = excluded.to_kit,
          to_phase = excluded.to_phase,
          action = excluded.action,
          status = excluded.status,
          request_path = excluded.request_path,
          response_path = excluded.response_path,
          enqueued_ts = excluded.enqueued_ts,
          completed_ts = excluded.completed_ts
        """,
        (
            request["project_id"],
            request["request_id"],
            request["parent_run_id"],
            request["child_run_id"],
            request["from_kit"],
            request["from_phase"],
            request["to_kit"],
            request["to_phase"],
            request["action"],
            request["status"],
            request["request_path"],
            request["response_path"],
            request["enqueued_ts"],
            request["completed_ts"],
        ),
    )


def index_projects(
    projects: list[dict[str, Any]],
    *,
    cleanup_stale_projects: bool = True,
) -> dict[str, Any]:
    db = db_path()
    conn = sqlite3.connect(str(db))
    conn.row_factory = sqlite3.Row
    ensure_schema(conn)

    if cleanup_stale_projects:
        # Remove stale project rows that were unregistered.
        active_ids = {p["project_id"] for p in projects}
        stale_rows = conn.execute("SELECT project_id FROM projects").fetchall()
        for row in stale_rows:
            pid = row["project_id"]
            if pid not in active_ids:
                _delete_project_rows(conn, pid)
                conn.execute("DELETE FROM projects WHERE project_id = ?", (pid,))

    indexed_runs = 0
    indexed_requests = 0
    missing_roots: list[str] = []

    for project in projects:
        _insert_project(conn, project)
        _delete_project_rows(conn, project["project_id"])

        runs_dir = project["master_kit_root_path"] / "runs"
        if not runs_dir.is_dir():
            missing_roots.append(project["master_kit_root"])
            continue

        run_roots = sorted(
            p for p in runs_dir.iterdir() if p.is_dir() and (p / "events.jsonl").is_file()
        )
        for run_root in run_roots:
            run, requests = parse_run(project=project, run_root=run_root)
            _insert_run(conn, run)
            indexed_runs += 1
            for request in requests:
                _insert_request(conn, request)
                indexed_requests += 1

    conn.commit()
    conn.close()

    return {
        "projects_indexed": len(projects),
        "runs_indexed": indexed_runs,
        "requests_indexed": indexed_requests,
        "missing_roots": missing_roots,
        "db_path": str(db),
    }


def prepare_projects(projects: list[dict[str, Any]]) -> list[dict[str, Any]]:
    prepared: list[dict[str, Any]] = []
    for project in projects:
        mk = Path(project["master_kit_root"]).expanduser().resolve()
        pr = Path(project["project_root"]).expanduser().resolve()
        prepared.append(
            {
                **project,
                "master_kit_root": str(mk),
                "project_root": str(pr),
                "master_kit_root_path": mk,
                "project_root_path": pr,
            }
        )
    return prepared


def maybe_seed_registry() -> list[dict[str, Any]]:
    projects = load_registry()
    if projects:
        return projects

    mk = current_master_kit_root()
    pr = current_project_root(mk)
    upsert_registry_project(master_kit_root=mk, project_root=pr, label=pr.name)
    return load_registry()


def load_dashboard_rows(query: str, params: tuple[Any, ...] = ()) -> list[dict[str, Any]]:
    conn = sqlite3.connect(str(db_path()))
    conn.row_factory = sqlite3.Row
    rows = conn.execute(query, params).fetchall()
    conn.close()
    return [dict(row) for row in rows]


def load_one_row(query: str, params: tuple[Any, ...] = ()) -> dict[str, Any] | None:
    conn = sqlite3.connect(str(db_path()))
    conn.row_factory = sqlite3.Row
    row = conn.execute(query, params).fetchone()
    conn.close()
    if row is None:
        return None
    return dict(row)


def summary_payload(project_id: str | None) -> dict[str, Any]:
    params: list[Any] = []
    project_clause = ""
    if project_id:
        project_clause = "WHERE project_id = ?"
        params.append(project_id)

    runs = load_one_row(
        f"""
        SELECT
          COUNT(*) AS total_runs,
          SUM(CASE WHEN status = 'running' THEN 1 ELSE 0 END) AS running_runs,
          SUM(CASE WHEN status = 'ok' THEN 1 ELSE 0 END) AS ok_runs,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) AS failed_runs
        FROM runs
        {project_clause}
        """,
        tuple(params),
    ) or {}

    reqs = load_one_row(
        f"""
        SELECT
          COUNT(*) AS total_requests,
          SUM(CASE WHEN status = 'ok' THEN 1 ELSE 0 END) AS ok_requests,
          SUM(CASE WHEN status = 'blocked' THEN 1 ELSE 0 END) AS blocked_requests,
          SUM(CASE WHEN status = 'failed' OR status IS NULL THEN 1 ELSE 0 END) AS failed_requests
        FROM requests
        {project_clause}
        """,
        tuple(params),
    ) or {}

    active_by_phase = load_dashboard_rows(
        f"""
        SELECT
          COALESCE(kit, 'unknown') AS kit,
          COALESCE(phase, 'unknown') AS phase,
          COUNT(*) AS count
        FROM runs
        {project_clause if project_clause else ''}
        {('AND' if project_clause else 'WHERE')} status = 'running'
        GROUP BY COALESCE(kit, 'unknown'), COALESCE(phase, 'unknown')
        ORDER BY count DESC, kit ASC, phase ASC
        """,
        tuple(params),
    )

    return {
        "runs": runs,
        "requests": reqs,
        "active_by_phase": active_by_phase,
    }


def graph_payload(project_id: str | None) -> dict[str, Any]:
    where = ""
    params: tuple[Any, ...] = ()
    if project_id:
        where = "WHERE project_id = ?"
        params = (project_id,)

    edges = load_dashboard_rows(
        f"""
        SELECT
          COALESCE(from_kit, 'unknown') AS from_kit,
          COALESCE(from_phase, '?') AS from_phase,
          COALESCE(to_kit, 'unknown') AS to_kit,
          COALESCE(to_phase, '?') AS to_phase,
          COUNT(*) AS total,
          SUM(CASE WHEN status = 'ok' THEN 1 ELSE 0 END) AS ok,
          SUM(CASE WHEN status = 'blocked' THEN 1 ELSE 0 END) AS blocked,
          SUM(CASE WHEN status = 'failed' OR status IS NULL THEN 1 ELSE 0 END) AS failed
        FROM requests
        {where}
        GROUP BY
          COALESCE(from_kit, 'unknown'),
          COALESCE(from_phase, '?'),
          COALESCE(to_kit, 'unknown'),
          COALESCE(to_phase, '?')
        ORDER BY total DESC, from_kit ASC, to_kit ASC
        """,
        params,
    )

    return {"edges": edges}


def parse_int(raw: str | None, default: int, minimum: int, maximum: int) -> int:
    if raw is None:
        return default
    try:
        value = int(raw)
    except ValueError:
        return default
    return max(minimum, min(maximum, value))


def list_runs_payload(query: dict[str, str]) -> dict[str, Any]:
    project_id = query.get("project_id")
    status = query.get("status")
    kit = query.get("kit")
    phase = query.get("phase")
    limit = parse_int(query.get("limit"), 200, 1, 2000)

    clauses: list[str] = []
    params: list[Any] = []

    if project_id:
        clauses.append("project_id = ?")
        params.append(project_id)
    if status:
        clauses.append("status = ?")
        params.append(status)
    if kit:
        clauses.append("kit = ?")
        params.append(kit)
    if phase:
        clauses.append("phase = ?")
        params.append(phase)

    where = ""
    if clauses:
        where = "WHERE " + " AND ".join(clauses)

    rows = load_dashboard_rows(
        f"""
        SELECT
          project_id,
          run_id,
          parent_run_id,
          kit,
          phase,
          status,
          started_at,
          finished_at,
          exit_code,
          cwd,
          project_root,
          master_kit_root,
          agent_runtime,
          host,
          pid,
          capsule_path,
          manifest_path,
          log_path,
          events_path
        FROM runs
        {where}
        ORDER BY COALESCE(started_at, '') DESC, run_id DESC
        LIMIT ?
        """,
        tuple([*params, limit]),
    )

    return {"runs": rows, "limit": limit}


def _parent_map(rows: list[dict[str, Any]]) -> dict[str, str | None]:
    return {str(row["run_id"]): row.get("parent_run_id") for row in rows if row.get("run_id") is not None}


def _root_for_run(run_id: str, parents: dict[str, str | None]) -> str:
    current = run_id
    seen: set[str] = set()
    while True:
        if current in seen:
            return run_id
        seen.add(current)
        parent = parents.get(current)
        if not isinstance(parent, str) or parent not in parents:
            return current
        current = parent


def run_detail_payload(project_id: str, run_id: str) -> dict[str, Any]:
    run = load_one_row(
        """
        SELECT *
        FROM runs
        WHERE project_id = ? AND run_id = ?
        """,
        (project_id, run_id),
    )
    if run is None:
        raise KeyError("run not found")

    all_runs = load_dashboard_rows(
        """
        SELECT *
        FROM runs
        WHERE project_id = ?
        """,
        (project_id,),
    )
    parents = _parent_map(all_runs)
    root = _root_for_run(run_id, parents)

    thread_runs = [
        item
        for item in all_runs
        if _root_for_run(str(item["run_id"]), parents) == root
    ]
    thread_runs.sort(key=lambda x: ((x.get("started_at") or ""), str(x.get("run_id") or "")))
    thread_run_ids = {str(item["run_id"]) for item in thread_runs if item.get("run_id")}

    conn = sqlite3.connect(str(db_path()))
    conn.row_factory = sqlite3.Row
    placeholders = ",".join("?" for _ in thread_run_ids) or "''"
    params: list[Any] = [project_id]
    params.extend(sorted(thread_run_ids))
    params.extend(sorted(thread_run_ids))
    request_rows = conn.execute(
        f"""
        SELECT *
        FROM requests
        WHERE project_id = ?
          AND (
            parent_run_id IN ({placeholders})
            OR child_run_id IN ({placeholders})
          )
        ORDER BY COALESCE(enqueued_ts, completed_ts, '') ASC, request_id ASC
        """,
        tuple(params),
    ).fetchall()
    conn.close()

    requests = [dict(row) for row in request_rows]

    return {
        "run": run,
        "thread_root_run_id": root,
        "thread_runs": thread_runs,
        "thread_requests": requests,
    }


INDEX_HTML = """<!doctype html>
<html lang=\"en\">
<head>
  <meta charset=\"utf-8\" />
  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />
  <title>Master-Kit Global Dashboard</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --line: #334155;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --ok: #22c55e;
      --bad: #ef4444;
      --warn: #f59e0b;
      --accent: #0ea5e9;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      --sans: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at top right, #1e293b, var(--bg) 55%);
      color: var(--text);
      font-family: var(--sans);
    }
    .wrap {
      max-width: 1320px;
      margin: 0 auto;
      padding: 18px;
    }
    h1 {
      margin: 0 0 12px;
      font-size: 22px;
      letter-spacing: 0.2px;
    }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px;
    }
    .panel {
      background: linear-gradient(180deg, var(--panel), #0b1220);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 12px;
      box-shadow: 0 10px 20px rgba(2, 6, 23, 0.25);
    }
    select, input, button {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 10px;
      font-family: var(--sans);
      font-size: 14px;
    }
    button {
      cursor: pointer;
      background: linear-gradient(180deg, #1d4ed8, #1e40af);
      border-color: #1e3a8a;
      font-weight: 600;
    }
    button.secondary {
      background: var(--panel-2);
      border-color: var(--line);
      font-weight: 500;
    }
    .cards {
      display: grid;
      grid-template-columns: repeat(6, minmax(110px, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }
    .card {
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.8);
      padding: 10px;
    }
    .card .k {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 4px;
    }
    .card .v {
      font-size: 22px;
      font-weight: 700;
    }
    .ok { color: var(--ok); }
    .bad { color: var(--bad); }
    .warn { color: var(--warn); }
    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      border-bottom: 1px solid var(--line);
      padding: 7px 8px;
      text-align: left;
      vertical-align: top;
    }
    th {
      color: var(--muted);
      font-weight: 600;
      background: rgba(15, 23, 42, 0.55);
      position: sticky;
      top: 0;
    }
    tbody tr:hover {
      background: rgba(30, 41, 59, 0.55);
      cursor: pointer;
    }
    .mono {
      font-family: var(--mono);
      font-size: 12px;
      word-break: break-all;
    }
    .muted { color: var(--muted); }
    .scroll {
      max-height: 360px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
    }
    .detail {
      white-space: pre-wrap;
      font-family: var(--mono);
      font-size: 12px;
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 10px;
      max-height: 380px;
      overflow: auto;
    }
    @media (max-width: 980px) {
      .cards { grid-template-columns: repeat(3, minmax(100px, 1fr)); }
      .grid2 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class=\"wrap\">
    <h1>Master-Kit Global Dashboard</h1>
    <div class=\"row panel\">
      <label>Project:
        <select id=\"project\"></select>
      </label>
      <label>Status:
        <select id=\"status\">
          <option value=\"\">all</option>
          <option value=\"running\">running</option>
          <option value=\"ok\">ok</option>
          <option value=\"failed\">failed</option>
        </select>
      </label>
      <label>Kit:
        <select id=\"kit\">
          <option value=\"\">all</option>
          <option value=\"tdd\">tdd</option>
          <option value=\"research\">research</option>
          <option value=\"math\">math</option>
        </select>
      </label>
      <label>Phase:
        <input id=\"phase\" placeholder=\"optional\" />
      </label>
      <button id=\"refresh-index\">Reindex</button>
      <button id=\"reload\" class=\"secondary\">Reload Views</button>
      <span id=\"stamp\" class=\"muted\"></span>
    </div>

    <div class=\"cards\" id=\"cards\"></div>

    <div class=\"grid2\">
      <div class=\"panel\">
        <h3 style=\"margin-top:0\">Phase Edges</h3>
        <div class=\"scroll\">
          <table>
            <thead><tr><th>edge</th><th>total</th><th>ok</th><th>blocked</th><th>failed</th></tr></thead>
            <tbody id=\"edges\"></tbody>
          </table>
        </div>
      </div>

      <div class=\"panel\">
        <h3 style=\"margin-top:0\">Running Now</h3>
        <div class=\"scroll\">
          <table>
            <thead><tr><th>run</th><th>phase</th><th>runtime</th><th>where</th></tr></thead>
            <tbody id=\"active\"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class=\"panel\">
      <h3 style=\"margin-top:0\">Runs (click row for thread explorer)</h3>
      <div class=\"scroll\">
        <table>
          <thead>
            <tr>
              <th>run_id</th><th>status</th><th>kit.phase</th><th>start</th><th>end</th><th>runtime</th><th>project_root</th><th>cwd</th>
            </tr>
          </thead>
          <tbody id=\"runs\"></tbody>
        </table>
      </div>
    </div>

    <div class=\"panel\">
      <h3 style=\"margin-top:0\">Thread Detail</h3>
      <div id=\"detail\" class=\"detail\">Select a run.</div>
    </div>
  </div>

<script>
const el = (id) => document.getElementById(id);

async function api(path, options = {}) {
  const res = await fetch(path, options);
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

function fmtStatus(s) {
  if (s === 'ok') return `<span class=\"ok\">${s}</span>`;
  if (s === 'failed') return `<span class=\"bad\">${s}</span>`;
  if (s === 'blocked') return `<span class=\"warn\">${s}</span>`;
  if (s === 'running') return `<span class=\"warn\">${s}</span>`;
  return s || '';
}

function queryString(params) {
  const q = new URLSearchParams();
  Object.entries(params).forEach(([k, v]) => {
    if (v !== '' && v !== null && v !== undefined) q.set(k, v);
  });
  return q.toString();
}

async function loadProjects() {
  const payload = await api('/api/projects');
  const select = el('project');
  select.innerHTML = '';

  const allOpt = document.createElement('option');
  allOpt.value = '';
  allOpt.textContent = 'all projects';
  select.appendChild(allOpt);

  for (const p of payload.projects) {
    const opt = document.createElement('option');
    opt.value = p.project_id;
    opt.textContent = `${p.label} [${p.project_id}]`;
    select.appendChild(opt);
  }
}

function card(label, value, klass = '') {
  return `<div class=\"card\"><div class=\"k\">${label}</div><div class=\"v ${klass}\">${value ?? 0}</div></div>`;
}

async function loadSummary() {
  const projectId = el('project').value;
  const s = await api(`/api/summary?${queryString({project_id: projectId})}`);
  const runs = s.summary.runs || {};
  const reqs = s.summary.requests || {};
  el('cards').innerHTML = [
    card('runs', runs.total_runs || 0),
    card('running', runs.running_runs || 0, 'warn'),
    card('run ok', runs.ok_runs || 0, 'ok'),
    card('run failed', runs.failed_runs || 0, 'bad'),
    card('requests', reqs.total_requests || 0),
    card('blocked req', reqs.blocked_requests || 0, 'warn')
  ].join('');
}

async function loadGraph() {
  const projectId = el('project').value;
  const payload = await api(`/api/graph?${queryString({project_id: projectId})}`);
  const tbody = el('edges');
  tbody.innerHTML = '';
  for (const e of payload.edges) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class=\"mono\">${e.from_kit}.${e.from_phase} -> ${e.to_kit}.${e.to_phase}</td>` +
      `<td>${e.total}</td><td class=\"ok\">${e.ok}</td><td class=\"warn\">${e.blocked}</td><td class=\"bad\">${e.failed}</td>`;
    tbody.appendChild(tr);
  }
}

async function loadActive() {
  const projectId = el('project').value;
  const payload = await api(`/api/active?${queryString({project_id: projectId})}`);
  const tbody = el('active');
  tbody.innerHTML = '';
  for (const r of payload.runs) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class=\"mono\">${r.run_id}</td>` +
      `<td>${r.kit || '?'}.${r.phase || '?'}</td>` +
      `<td>${r.agent_runtime || 'direct'}@${r.host || '?'}</td>` +
      `<td class=\"mono\">${r.project_root || ''}</td>`;
    tbody.appendChild(tr);
  }
}

async function loadRuns() {
  const payload = await api(`/api/runs?${queryString({
    project_id: el('project').value,
    status: el('status').value,
    kit: el('kit').value,
    phase: el('phase').value,
    limit: 500,
  })}`);

  const tbody = el('runs');
  tbody.innerHTML = '';
  for (const r of payload.runs) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class=\"mono\">${r.run_id}</td>` +
      `<td>${fmtStatus(r.status)}</td>` +
      `<td>${(r.kit || '?') + '.' + (r.phase || '?')}</td>` +
      `<td class=\"mono\">${r.started_at || ''}</td>` +
      `<td class=\"mono\">${r.finished_at || ''}</td>` +
      `<td>${r.agent_runtime || 'direct'}@${r.host || '?'}</td>` +
      `<td class=\"mono\">${r.project_root || ''}</td>` +
      `<td class=\"mono\">${r.cwd || ''}</td>`;
    tr.addEventListener('click', () => loadRunDetail(r.project_id, r.run_id));
    tbody.appendChild(tr);
  }
}

async function loadRunDetail(projectId, runId) {
  const payload = await api(`/api/run?${queryString({project_id: projectId, run_id: runId})}`);
  const detail = {
    selected_run: payload.run,
    thread_root_run_id: payload.thread_root_run_id,
    thread_runs: payload.thread_runs.map(r => ({
      run_id: r.run_id,
      parent_run_id: r.parent_run_id,
      phase: `${r.kit || '?'}.${r.phase || '?'}`,
      status: r.status,
      started_at: r.started_at,
      finished_at: r.finished_at,
      runtime: `${r.agent_runtime || 'direct'}@${r.host || '?'}`,
      where: r.project_root,
      cwd: r.cwd,
      log_path: r.log_path,
      manifest_path: r.manifest_path,
      capsule_path: r.capsule_path,
    })),
    thread_requests: payload.thread_requests.map(r => ({
      request_id: r.request_id,
      edge: `${r.from_kit || '?'}.${r.from_phase || '?'} -> ${r.to_kit || '?'}.${r.to_phase || '?'}`,
      status: r.status,
      parent_run_id: r.parent_run_id,
      child_run_id: r.child_run_id,
      action: r.action,
      enqueued_ts: r.enqueued_ts,
      completed_ts: r.completed_ts,
      response_path: r.response_path,
    })),
  };

  el('detail').textContent = JSON.stringify(detail, null, 2);
}

async function loadAll() {
  await Promise.all([loadSummary(), loadGraph(), loadActive(), loadRuns()]);
  el('stamp').textContent = `updated ${new Date().toLocaleString()}`;
}

el('refresh-index').addEventListener('click', async () => {
  const projectId = el('project').value;
  await api('/api/refresh', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(projectId ? {project_id: projectId} : {}),
  });
  await loadAll();
});

el('reload').addEventListener('click', loadAll);
el('project').addEventListener('change', loadAll);
el('status').addEventListener('change', loadRuns);
el('kit').addEventListener('change', loadRuns);
el('phase').addEventListener('change', loadRuns);

(async function boot() {
  await loadProjects();
  await loadAll();
})();
</script>
</body>
</html>
"""


class DashboardHandler(BaseHTTPRequestHandler):
    state_lock = threading.Lock()
    projects: list[dict[str, Any]] = []

    @property
    def json_headers(self) -> dict[str, str]:
        return {"Content-Type": "application/json"}

    def log_message(self, fmt: str, *args: Any) -> None:
        stamp = now_iso()
        print(f"[{stamp}] dashboard {self.client_address[0]} {fmt % args}", flush=True)

    def _write(self, status: int, body: bytes, content_type: str) -> None:
        self.send_response(status)
        self.send_header("Content-Type", content_type)
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def _write_json(self, status: int, payload: dict[str, Any]) -> None:
        body = json.dumps(payload, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
        self._write(status, body, "application/json")

    def _read_json_body(self) -> dict[str, Any]:
        raw_len = int(self.headers.get("Content-Length", "0") or "0")
        if raw_len <= 0:
            return {}
        data = self.rfile.read(raw_len)
        try:
            body = json.loads(data.decode("utf-8"))
        except Exception as exc:
            raise ValueError(f"invalid json body: {exc}") from exc
        if not isinstance(body, dict):
            raise ValueError("json body must be an object")
        return body

    def _query(self) -> dict[str, str]:
        parsed = urllib.parse.urlparse(self.path)
        raw = urllib.parse.parse_qs(parsed.query)
        return {k: v[-1] for k, v in raw.items() if v}

    def _route_path(self) -> str:
        return urllib.parse.urlparse(self.path).path

    def do_GET(self) -> None:  # noqa: N802
        route = self._route_path()
        try:
            if route == "/":
                self._write(HTTPStatus.OK, INDEX_HTML.encode("utf-8"), "text/html; charset=utf-8")
                return

            if route == "/api/projects":
                rows = load_dashboard_rows(
                    "SELECT project_id, label, master_kit_root, project_root FROM projects ORDER BY label ASC"
                )
                self._write_json(HTTPStatus.OK, {"projects": rows})
                return

            if route == "/api/summary":
                query = self._query()
                payload = summary_payload(query.get("project_id"))
                self._write_json(HTTPStatus.OK, {"summary": payload})
                return

            if route == "/api/graph":
                query = self._query()
                payload = graph_payload(query.get("project_id"))
                self._write_json(HTTPStatus.OK, payload)
                return

            if route == "/api/active":
                query = self._query()
                params: list[Any] = []
                where = "WHERE status = 'running'"
                project_id = query.get("project_id")
                if project_id:
                    where += " AND project_id = ?"
                    params.append(project_id)
                runs = load_dashboard_rows(
                    f"""
                    SELECT project_id, run_id, kit, phase, status, started_at, agent_runtime, host, pid, project_root
                    FROM runs
                    {where}
                    ORDER BY COALESCE(started_at, '') DESC
                    """,
                    tuple(params),
                )
                self._write_json(HTTPStatus.OK, {"runs": runs})
                return

            if route == "/api/runs":
                payload = list_runs_payload(self._query())
                self._write_json(HTTPStatus.OK, payload)
                return

            if route == "/api/run":
                query = self._query()
                project_id = query.get("project_id")
                run_id = query.get("run_id")
                if not project_id or not run_id:
                    self._write_json(HTTPStatus.BAD_REQUEST, {"error": "project_id and run_id are required"})
                    return
                payload = run_detail_payload(project_id, run_id)
                self._write_json(HTTPStatus.OK, payload)
                return

            if route == "/health":
                self._write_json(HTTPStatus.OK, {"ok": True, "ts": now_iso()})
                return

            self._write_json(HTTPStatus.NOT_FOUND, {"error": "not found"})
        except KeyError as exc:
            self._write_json(HTTPStatus.NOT_FOUND, {"error": str(exc)})
        except Exception as exc:  # pragma: no cover - defensive
            self._write_json(HTTPStatus.INTERNAL_SERVER_ERROR, {"error": str(exc)})

    def do_POST(self) -> None:  # noqa: N802
        route = self._route_path()
        if route != "/api/refresh":
            self._write_json(HTTPStatus.NOT_FOUND, {"error": "not found"})
            return

        try:
            body = self._read_json_body()
            project_id = body.get("project_id")
            if project_id is not None and (not isinstance(project_id, str) or not project_id):
                raise ValueError("project_id must be a non-empty string when provided")

            with self.state_lock:
                projects = maybe_seed_registry()
                prepared = prepare_projects(projects)
                if isinstance(project_id, str):
                    prepared = [p for p in prepared if p["project_id"] == project_id]
                result = index_projects(
                    prepared,
                    cleanup_stale_projects=not isinstance(project_id, str),
                )

            self._write_json(HTTPStatus.OK, {"refreshed": result})
        except ValueError as exc:
            self._write_json(HTTPStatus.BAD_REQUEST, {"error": str(exc)})
        except Exception as exc:  # pragma: no cover - defensive
            self._write_json(HTTPStatus.INTERNAL_SERVER_ERROR, {"error": str(exc)})


class DashboardServer(ThreadingHTTPServer):
    daemon_threads = True


def cmd_register(args: argparse.Namespace) -> int:
    default_mk = current_master_kit_root()
    master_kit_root = coerce_path(args.master_kit_root, default_mk)
    project_root = coerce_path(args.project_root, current_project_root(master_kit_root))

    if not (master_kit_root / "tools" / "kit").is_file():
        print(f"Error: not a master-kit root: {master_kit_root}")
        return 2

    record = upsert_registry_project(
        master_kit_root=master_kit_root,
        project_root=project_root,
        label=args.label,
    )
    print(json.dumps(record, sort_keys=True))
    return 0


def cmd_unregister(args: argparse.Namespace) -> int:
    removed = remove_registry_project(args.project_id)
    if not removed:
        print(f"No project found for id={args.project_id}")
        return 1
    print(f"removed project_id={args.project_id}")
    return 0


def cmd_projects(_: argparse.Namespace) -> int:
    projects = load_registry()
    if not projects:
        print("[]")
        return 0
    print(json.dumps(sorted(projects, key=lambda x: x["label"].lower()), indent=2, sort_keys=True))
    return 0


def cmd_index(args: argparse.Namespace) -> int:
    projects = maybe_seed_registry()
    prepared = prepare_projects(projects)
    if args.project_id:
        prepared = [p for p in prepared if p["project_id"] == args.project_id]

    if not prepared:
        print("No registered projects to index.")
        return 1

    result = index_projects(
        prepared,
        cleanup_stale_projects=not bool(args.project_id),
    )
    print(json.dumps(result, sort_keys=True))
    return 0


def cmd_serve(args: argparse.Namespace) -> int:
    projects = maybe_seed_registry()
    prepared = prepare_projects(projects)
    if args.project_id:
        prepared = [p for p in prepared if p["project_id"] == args.project_id]
    if not prepared:
        print("No registered projects to index/serve.")
        return 1

    seed = index_projects(
        prepared,
        cleanup_stale_projects=not bool(args.project_id),
    )
    print(f"dashboard indexed: {json.dumps(seed, sort_keys=True)}", flush=True)

    host = args.host
    port = args.port
    server = DashboardServer((host, port), DashboardHandler)

    print(f"dashboard ready url=http://{host}:{port}", flush=True)
    try:
        server.serve_forever(poll_interval=0.5)
    except KeyboardInterrupt:
        pass
    finally:
        server.server_close()
    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="tools/dashboard", add_help=True)
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_register = sub.add_parser("register", help="Register or update a project for global indexing")
    p_register.add_argument("--master-kit-root", default=None)
    p_register.add_argument("--project-root", default=None)
    p_register.add_argument("--label", default=None)
    p_register.set_defaults(func=cmd_register)

    p_unregister = sub.add_parser("unregister", help="Unregister a project id")
    p_unregister.add_argument("--project-id", required=True)
    p_unregister.set_defaults(func=cmd_unregister)

    p_projects = sub.add_parser("projects", help="List registered projects")
    p_projects.set_defaults(func=cmd_projects)

    p_index = sub.add_parser("index", help="Rebuild dashboard index from registered projects")
    p_index.add_argument("--project-id", default=None)
    p_index.set_defaults(func=cmd_index)

    p_serve = sub.add_parser("serve", help="Run HTTP dashboard server")
    p_serve.add_argument("--host", default=os.getenv("MASTER_KIT_DASHBOARD_HOST", "127.0.0.1"))
    p_serve.add_argument("--port", type=int, default=int(os.getenv("MASTER_KIT_DASHBOARD_PORT", "7340")))
    p_serve.add_argument("--project-id", default=None)
    p_serve.set_defaults(func=cmd_serve)

    return parser


def main(argv: list[str]) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    return int(args.func(args))


if __name__ == "__main__":
    raise SystemExit(main(os.sys.argv[1:]))
